{"version":3,"file":"options.js","sourceRoot":"","sources":["../../src/options.ts"],"names":[],"mappings":";AAgMa,uBAAe,GAAwB;IAClD,SAAS,EAAE,GAAG;IACd,GAAG,EAAE,KAAK;IACV,YAAY,EAAE,YAAY;IAC1B,aAAa,EAAE,WAAW;IAC1B,MAAM,EAAE,eAAe;IACvB,MAAM,EAAE,EAAE;IACV,MAAM,EAAE,IAAI;IACZ,QAAQ,EAAE,IAAI;IACd,WAAW,EAAE,OAAO,CAAC,GAAG,EAAE;CAC3B,CAAC;AAEW,gCAAwB,GAAyB;IAC5D,MAAM,EAAE,SAAS;IACjB,SAAS,EAAE,SAAS;IACpB,QAAQ,EAAE,SAAS;CACpB,CAAC","sourcesContent":["export type BUILT_IN_LOADERS = 'sync' | 'async-require' | 'async-system';\r\n\r\n/**\r\n * Loader options for the `ng-router-loader`.\r\n *\r\n * ## Resource specific options\r\n * Some options apply to a resource, the global option serve as the default but can be overridden in a resource URI using query parameters.\r\n *\r\n * >Resource specific options are marked with the **resource_override** tag.\r\n *\r\n * #### AOT mode\r\n * Some of the options apply on when the `aot` flag is set to **true**.\r\n *\r\n * >AOT specific options are marked with the **aot_mode** tag.\r\n *\r\n *\r\n * ## Usage\r\n * #### Webpack 1\r\n * ```ts\r\n * {\r\n *    test: /\\.ts$/,\r\n *    loaders: [\r\n *      'awesome-typescript-loader',\r\n *      'ng-router-loader?aot=true&genDir=codegen'\r\n *    ]\r\n * }\r\n * ```\r\n *\r\n * #### Webpack 2\r\n * You can use the query string as well as:\r\n * ```ts\r\n * {\r\n *    test: /\\.ts$/,\r\n *    use: [\r\n *      'awesome-typescript-loader',\r\n *      {\r\n *         loader: 'ng-router-loader',\r\n *         options: {\r\n *           aot: true,\r\n *           genDir: 'codegen'\r\n *         }\r\n *      }\r\n *    ]\r\n * }\r\n * ```\r\n */\r\nexport interface RouterLoaderOptions {\r\n  /**\r\n   * A separator used to identify the NgModule class name in the URI.\r\n   * @default '#'\r\n   */\r\n  delimiter?: string;\r\n\r\n  /**\r\n   * Enable support for AOT compiled code.\r\n   * If you are bundling AOT compiled code (.ngfactory) set this to true\r\n   * @default false\r\n   */\r\n  aot?: boolean;\r\n\r\n  /**\r\n   * The suffix used by the angular compiler to mark compiled version of source tree modules.\r\n   *\r\n   * @aot_mode\r\n   * @default '.ngfactory'\r\n   */\r\n  moduleSuffix?: string;\r\n\r\n  /**\r\n   * The suffix used by the angular compiler to mark compiled version of source tree NgModule class.\r\n   *\r\n   * @aot_mode\r\n   * @default 'NgFactory'\r\n   */\r\n  factorySuffix?: string;\r\n\r\n  /**\r\n   * The code generator to use when replacing the URI with a callback.\r\n   *\r\n   * There are 3 built in code generators:\r\n   *   - sync: The module will be part of the bundle (lazy initializing but NOT lazy loading)\r\n   *   - async-require: The module will load in a separate bundle, using webpack's `require.ensure` feature (support chunkName)\r\n   *   - async-system: The module will load in a separate bundle using System.import\r\n   *\r\n   *   Note: System.import is deprecated in Webpack 2, will be removed in webpack 3 (https://github.com/webpack/webpack/releases/tag/v2.1.0-beta.28)\r\n   *\r\n   * You can override the loader in a specific resource by setting the loader in a resource query.\r\n   *\r\n   * @resource_override\r\n   * @default 'async-require'\r\n   */\r\n  loader?: BUILT_IN_LOADERS | string;\r\n\r\n  /**\r\n   * The destination of compiled files created by the angular compiler-cli.\r\n   * The directory is resolved relative to the current working directory (process.cwd())\r\n   *\r\n   * When genDir is empty or \".\" the destination is the project root and factory files are saved along side the source tree.\r\n   *\r\n   * IMPORTANT NOTE:\r\n   * The compiler-cli takes this value from the tsconfig file @ \"angularCompilerOptions.genDir\" and\r\n   * resolve the destination with \"genDir\" relative to the \"tsconfig\" file.\r\n   * Webpack (hence the loader) run on a different process so it does not know about that \"tsconfig\".\r\n   * If your setup is complex you need to make sure that the 2 \"genDir\"s resolve to the same directory according to the logic described here.\r\n   *\r\n   * The best scenario is when \"tsconfig.json\" is in the project root and webpack is executed from the project root.\r\n   * In this case the \"genDir\" should be identical to the \"genDir\" value in \"tsconfig.json\"\r\n   *\r\n   * @aot_mode\r\n   * @default ''\r\n   */\r\n  genDir?: string;\r\n\r\n  /**\r\n   * If false outputs a pretty code\r\n   *\r\n   * @default true\r\n   */\r\n  inline?: boolean;\r\n\r\n  debug?: boolean;\r\n\r\n  /**\r\n   * Resolve ngfactory modules and verify they exist, if not track the symbol and search for the ngfactory\r\n   * that exports the symbol.\r\n   *\r\n   * AOT compilation emit ngfactory files only for NgModule, Component and Directive.\r\n   * If a module does not have one of those the compiler will not create an ngfactory file for it.\r\n   *\r\n   * In webpack it is a common practice to use directories as packages (barrel pattern) having an\r\n   * index file exporting what's needed.\r\n   *\r\n   * When a URI reference a module (ModA) that:\r\n   * - export an NgModule defined in an other module (ModB) and;\r\n   * - ModA has no NgModule, Component or Directive defined inside it\r\n   *\r\n   * The resolved file will \"ModA.ngfactory\", even though it does not exists.\r\n   * When bySymbol is true the loader will use the metadata in \"ngsummary.json\" files to lookup the\r\n   * first ngfactory file that exports ModB, it will then use it as the resolved URI.\r\n   *\r\n   * You can override this option in a specific resource by setting the bySymbol property in a resource query.\r\n   *\r\n   * @resource_override\r\n   * @aot_mode\r\n   * @default true\r\n   */\r\n  bySymbol?: boolean;\r\n  /**\r\n   * For complex folder structures it could be necessary to set de full path of the tsconfig file\r\n   * If your setup is complex  sometimes resolving the 2 \"genDir\"s  to the same directory is not enough\r\n   * If you don't set this option, the tsconfig will be relative to the process.cwd() directory\r\n   * @aot_mode\r\n   * @default 'process.cwd()'\r\n   */\r\n  tsconfigDir?: string;\r\n}\r\n\r\n/**\r\n * Resource specific options, defined as query string on the resource URI.\r\n *\r\n * ```\r\n * {\r\n *   path: 'home',\r\n *   loadChildren: './app/home/home-module#HomeModule?loader=sync&bySymbol=false'\r\n * }\r\n * ```\r\n */\r\nexport interface RouteResourceOptions {\r\n  /**\r\n   * The code generator to use when replacing the URI with a callback.\r\n   *\r\n   * @resource_override RouterLoaderOptions.loader\r\n   */\r\n  loader?: BUILT_IN_LOADERS | string;\r\n\r\n  /**\r\n   * A chunk name used by webpack to bundle async modules.\r\n   * Used by the \"async-require\" loader.\r\n   *\r\n   * For more information see [webpack require.ensure](https://webpack.js.org/guides/code-splitting/#code-splitting-with-require-ensure-)\r\n   */\r\n  chunkName?: string;\r\n\r\n  /**\r\n   * Resolve ngfactory modules and verify they exist, if not track the symbol and search for the ngfactory\r\n   * that exports the symbol.\r\n   *\r\n   * @resource_override RouterLoaderOptions.loader\r\n   */\r\n  bySymbol?: boolean;\r\n}\r\n\r\nexport const DEFAULT_OPTIONS: RouterLoaderOptions = {\r\n  delimiter: '#',\r\n  aot: false,\r\n  moduleSuffix: '.ngfactory',\r\n  factorySuffix: 'NgFactory',\r\n  loader: 'async-require',\r\n  genDir: '',\r\n  inline: true,\r\n  bySymbol: true,\r\n  tsconfigDir: process.cwd()\r\n};\r\n\r\nexport const DEFAULT_RESOURCE_OPTIONS: RouteResourceOptions = {\r\n  loader: undefined,\r\n  chunkName: undefined,\r\n  bySymbol: undefined\r\n};\r\n\r\n"]}